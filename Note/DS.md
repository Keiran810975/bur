# 数据结构

## 链表

* 单向链表
* 双向链表
* 循环链表

## 栈

* 栈顶指针初始为-1
* **栈存储数字/字符串/结构体**

## 队列

* 队列
* 循环队列
    * 队头指针front、队尾指针rear初始化都为0
    * 队头队尾指针相同时，队空
    * 入队：rear+1，再%MAX，队尾存新元素
    * 出队：front+1，再%MAX
    * (rear+1)%MAX==front，队满
    * 队头元素的索引是front+1
    * 队尾元素的索引是rear
* 优先队列(小根堆)

## 二叉树

* 二叉搜索树
* 前序遍历
* 中序遍历
* 后序遍历
* 层序遍历
* 哈夫曼树(结点数，叶结点数)
* 二叉查找树
* LCA函数
* B-树 B+树
* 多叉树
* 三叉树

## 查找

* 折半二分查找
* 哈希表
* 插值查找

## 排序

* 冒泡排序(稳定)  **最好n  最坏n^2**
* 选择排序(不稳定)   **永远是n^2**
* 插入排序(稳定)  **最好n  最坏n^2**
* 快速排序(原理)(不稳定)(每轮排序都会有一个元素到正确位置)**最好nlogn  最坏n^2 平均nlogn**
* 堆排序(先建立大根堆，然后根结点往下沉)(不稳定)**nlogn**
* 归并排序(稳定)(在一趟结束后不一定能选出一个元素放在其最终位置上)  **nlogn**
* 桶排序(不稳定)
* 基数排序(稳定)
* 计数排序(稳定)
* 希尔排序(不稳定)
* 折半插入排序(稳定)

## 图

* 边上带权的图成为**网络**
* 顶点的度(有向图的出度、入度)
* 三个结论:[fa](E:\图片\其他\map.png)
* 连通图:任意两顶点之间都连通
* 连通分量：极大连通子图
* 生成树(一般情况下，生成树不唯一)
* 邻接矩阵
* 三元组存储(稀疏矩阵)
* 邻接表
* 拓扑排序(对于有向无环图):依次取出入度为0的顶点
* Prim算法
* kruskal算法
* dijkstra算法
* floyd算法(不考)
* AOE网(不考)
* AOV网(不考)

## 复习

- [x] 快速排序原理
- [x] 哈夫曼树创建,带权路径
    >叶节点权值*高度 总和(根结点高度是0)
    哈夫曼树叶结点数n，总结点数为2n-1
- [x] prim
    >基于邻接矩阵的实现时间复杂度为**O(n^2)**,基于邻接表并使用最小堆优化的实现时间复杂度为**O((n + e) \log n)**
- [x] kruskal
    >**简单的**那个是kruskal，直接从小到大往图里回填边，最小生成树的边数是**n-1**(n为结点数)，时间复杂度**O(eloge)**
- [x] 判定树
- [x] 折半查找 平均搜索长度(层高 * 层结点数，总和，再除以总结点数)
- [x] 前缀编码
- [x] 归并排序原理
- [x] dijkstra
- [x] 拓扑排序
- [x] 连通图
- [x] B-树
    >m阶B树，结点中关键字个数的范围：(m/2)向下取整~m-1
    **B树的所有叶结点在同一层上**
- [x] 前后缀表达式的计算(后缀从头开始压栈，前缀从尾开始压栈)