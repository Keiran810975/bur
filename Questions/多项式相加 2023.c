对于本道题，如果多项式的每⼀项指数部分都在 这样的范围内，则我们只需要设置⼀个数组每
次读入的时候以指数部分作为数组下标，将系数记录进 数组中即可完成任务。但本题中指数范围较大，
直接采用上述方法进行计算将会导致数组越界，因此需要考虑其他方法。
我们用二维数组存储多项式，其中每个元素是长度为 的一维数组，存储每一项的系数和指数。
虽然题目中的 都是以乱序给出的，但如果我们假设是以降序给出，可以考虑这样⼀种做法：
1. 用两个变量 记录当前正在处理从大到小的第 或 项。⼀开始时 。
2. 比较第 项和第 项的指数部分：
若指数部分相同说明这两项的系数部分在结果中应当相加，并将 都向后移动⼀位；
若 对应的指数部分较大，说明只有 在结果的这⼀项中出现，并将 向后移动⼀位；
若 对应的指数部分较大，说明只有 在结果的这一项中出现，并将 向后移动一位；
当 将 的每⼀项都计算之后，最后结果的多项式也被计算出来了。可以发现，通过该方法
得到的多项式，其指数部分也是严格递减的。由于 只会移动最多 次，因此总循环次数不超过
次，可以在题目要求的时间范围内完成计算。
最后，由于题目是乱序给出的，所以需要先对两个数组按照指数降序排序。代码如下
示例代码 - 1
#include <stdio.h>
#include <stdlib.h>
int a[100000][2] = {0};
int b[100000][2] = {0};
//排序规则：按照指数（二维数组每行下标为1的元素）降序排序
int cmpfunc(const void *p, const void *q)
{
return ((int*)q)[1] - ((int*)p)[1];
}
int main()
{
int n, m, i, j;
scanf("%d%d", &n, &m);
for (i = 0; i < n; i++)
scanf("%d%d", &a[i][0], &a[i][1]);
for (i = 0; i < m; i++)
scanf("%d%d", &b[i][0], &b[i][1]);
qsort(a, n, sizeof(int[2]), cmpfunc);
qsort(b, m, sizeof(int[2]), cmpfunc);
i = j = 0;
while (i < n || j < m) //只要还有剩余的项没被计算，就应继续循环
{
if (j == m || a[i][1] > b[j][1])
{
printf("%d %d ", a[i][0], a[i][1]);
i++;
}
else if (i == n || a[i][1] < b[j][1])
{
printf("%d %d ", b[j][0], b[j][1]);
j++;
}
else
{
if (a[i][0] + b[j][0] != 0)
printf("%d %d ", a[i][0] + b[j][0], a[i][1]);
i++;
j++;
}
}
return 0;
}